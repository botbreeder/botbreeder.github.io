<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>botbreeder.github.io</title>
    <link href="https://botbreeder.github.io/feed.xml" rel="self" />
    <link href="https://botbreeder.github.io" />
    <updated>2024-04-25T09:51:01+02:00</updated>
    <author>
        <name>Julien Laguerre</name>
    </author>
    <id>https://botbreeder.github.io</id>

    <entry>
        <title>40 miles of bad road</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/40-miles-of-bad-road.html"/>
        <id>https://botbreeder.github.io/40-miles-of-bad-road.html</id>

        <updated>2024-04-25T09:44:01+02:00</updated>
            <summary>
                <![CDATA[
                    It's been a long way. At some point, I thought I'd never reach the other end of the tunnel. But I did. More infrastructure was needed to support the complete cycle, input / calculus / output. There were also subtle bugs, now eradicated. I even&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>It's been a long way. At some point, I thought I'd never reach the other end of the tunnel. But I did. More infrastructure was needed to support the complete cycle, input / calculus / output. There were also subtle bugs, now eradicated.</p>
<p>I even had to reshape the syntax parser a little bit. Indeed, the value part of a table was accepting lists of items, for example <code>| 1 2 3 | 4 5 6Â  </code>Â but the meaning was unclear. Now the value of a table is not a list of list anymore, but just a list. We can still use parentheses to create lists of lists of course.</p>
<p>At first, the tables would mutate even while you create them, which was a bit weird. So I changed that, and now a space that's currently being modified by the user is marked as "suspended", so no mutation happen during edition.</p>
<p>I'm about to implement a few more operators and start playing around with my shiny new toy.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Closing the loop</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/closing-the-loop.html"/>
        <id>https://botbreeder.github.io/closing-the-loop.html</id>

        <updated>2024-04-20T16:44:45+02:00</updated>
            <summary>
                <![CDATA[
                    The loop is the propagation of changes between the user and the system. The input side of the loop is implemented, and I had the joy to witness a sum! When a table's values change, all the tables that watch its name get properly recalculated.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>The loop is the propagation of changes between the user and the system. The input side of the loop is implemented, and I had the joy to witness a sum! When a table's values change, all the tables that watch its name get properly recalculated.</p>
<p>So the sum is now happening in Hup. Other operators won't need a lot of work, so I'm rather focusing on the other part of the loop, the feedback. To implement feedback, I want source code generation to be comments and newlines aware. So I'll modify the parser to make a "shape aware" version of it. Basically, everything in tables' values will be wiped out (because how would I choose where each comment would survive), and everything else will stay the same. The only thing I'll keep from values is whether they are all on the same line, or each on a line of its own.</p>
<p>I can feel the part of me that doesn't want to go further. It's not happy.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Meta</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/meta.html"/>
        <id>https://botbreeder.github.io/meta.html</id>

        <updated>2024-04-15T17:57:09+02:00</updated>
            <summary>
                <![CDATA[
                    I could look at my design and call it a day, but there's one thing I'm definitely not satisfied with. Hup is all oriented towards the description of high-level "mental" operations. You can't parse a string of characters, or even just print a mere "hello&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>I could look at my design and call it a day, but there's one thing I'm definitely not satisfied with.</p>
<p>Hup is all oriented towards the description of high-level "mental" operations. You can't parse a string of characters, or even just print a mere "hello world" to the screen. (Well yeah, you can.) But where Hup shines is elsewhere. It's vastly superior to any kind of supercharged Behavior Tree I've seen here and there, even to <a href="https://plexil-group.github.io/plexil_docs/" target="_blank" rel="noopener noreferrer">Plexil</a>, and it's so friendly and pragmatic compared to Prolog. So clearly this is our target here, high-level stuff, mental behaviors themselves.</p>
<p>But Hup's weakness, as it is today, is metaprogramming. Sure you can have tables generating tables on the fly, and you can also switch from state-thinking to event-thinking using the natural recursion capability of formulas. But it doesn't mean it would be easy to write programs that evolve, and I don't like it. I want more.</p>
<p>Let me explain what we can do now. We can have tables which generate values which are other tables. These other tables are first class citizens too, no problem. Another thing we can do is using recursion to make values evolve over time by themselves, for example <code>[ one more = [one more] 1 | 1 ]</code> would keep adding ones to its list of values.</p>
<p>But meta is another thing entirely. It's about structural, it's about runtime mutation. I don't know. I have this idea of "meta-tables" in the back of my head for some time now. A meta-table would obviously contain data about a regular table. I don't know if <em>that</em> idea of meta-tables and <em>this</em> desire of metaprogramming are somehow related. All I know is that I'm not done yet.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Base structure</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/base-structure.html"/>
        <id>https://botbreeder.github.io/base-structure.html</id>

        <updated>2024-04-14T12:39:12+02:00</updated>
            <summary>
                <![CDATA[
                    Yet another load of cosmetic details here and there, so many that I don't count them anymore. But... I also worked on the main thing. So I have a basic structure that now works correctly, and while the UI code is all wild and organic,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Yet another load of cosmetic details here and there, so many that I don't count them anymore. But...</p>
<p>I also worked on the main thing. So I have a basic structure that now works correctly, and while the UI code is all wild and organic, the engine code is well structured and commented JSDoc style. Programming "correctly" is surprisingly more error prone than my natural code-fu, but I finally eradicated all those nasty little bugs.</p>
<p>Now, the structure is as follows. Tables are associated with spaces, and names. Names are not unique to tables. Several tables can have the same name, that's why a table is identified by a generic ID and a name is a set of IDs of tables that share that name. Same goes for spaces, since spaces contain tables. The purpose of names and spaces are different though: names are how a table references other tables in a formula, while spaces form a logical partition of data in Hup, mainly for communication with the outer world.</p>
<p>Spaces are either "exposed" or not. Exposed spaces are the ones that are visible outside the engine. This is where you'd plug any external devices, and where the UI is connected. Exposed means, "read/write accessible from the outside."</p>
<p>For now, you register callback functions to expose a space, then when the tables in that space change, the callback is called, either with a text version of the content, or with the AST. Simple.</p>
<hr>
<p><span style="text-decoration: line-through;">On the FUI front, I had some sort of revelation the other day. UIs always have either light or dark modes, but perhaps it would be interesting to get past this. The content would be dark mode, but the container would be light mode, in shades of white and grey, white for unoccupied screen areas, grey for grouping contents. Lines and shapes would be diagonal where appropriate. </span><span style="text-decoration: line-through;">It's worth a try.</span></p>
<p>Do not try to bend the spoon. I tried this light&amp;dark thing and it was ugly as hell. Then I understood that my UI was meant to disappear behind the user's UI. The user-developer would setup a frontend, with Hup as the backend. Then the user-users (the users of the user-developer's app) wouldn't see Hup's UI, unless they hit F12 or something, to have a look behind the curtain. They'd see the frontend of the user-developer's app. And <em>that</em> spoon isn't my business.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bells and whistles et caetera</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/bells-and-whistles-et-caetera.html"/>
        <id>https://botbreeder.github.io/bells-and-whistles-et-caetera.html</id>

        <updated>2024-04-08T16:35:44+02:00</updated>
            <summary>
                <![CDATA[
                    I couldn't start working on the interpreter without getting comfortable first... So I added a few things to the interface. Code editors driven by Codemirror, a proper syntax highlighter (which still doesn't catch a few edge cases), and even a fancy little scrollmap on the&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <div class="gallery-wrapper"><div class="gallery"  data-is-empty="false" data-translation="Add images" data-columns="1">
<figure class="gallery__item"><a href="https://botbreeder.github.io/media/posts/13/gallery/wip-interface.PNG" data-size="1920x1080"><img loading="lazy" src="https://botbreeder.github.io/media/posts/13/gallery/wip-interface-thumbnail.PNG" alt="Screenshot of the WIP on the interface" width="720" height="405"></a></figure>
</div></div>
<p>I couldn't start working on the interpreter without getting comfortable first... So I added a few things to the interface. Code editors driven by <a href="https://codemirror.net/5/" target="_blank" rel="noopener noreferrer">Codemirror</a>, a proper syntax highlighter (which still doesn't catch a few edge cases), and even a fancy little scrollmap on the right-hand side of the screen, thanks to <a href="https://larsjung.de/pagemap/" target="_blank" rel="noopener noreferrer">Pagemap</a>.</p>
<p>I know I'll be tweaking this... like, forever. But now I can start setting up the interpreter!</p>
<p>Oh, and I added comments to the parser. Oldie goldies, <code>/* ... */</code> and <code>// ...</code>Â </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Parsing in Js after all</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/parsing-in-javascript-after-all.html"/>
        <id>https://botbreeder.github.io/parsing-in-javascript-after-all.html</id>

        <updated>2024-04-01T15:55:02+02:00</updated>
            <summary>
                <![CDATA[
                    Oh... kay... I've been a little optimistic there. ðŸ˜… I needed to move on, so I decided to switch back to good old Javascript. I used PEGGYjs, which is the properly maintained child of PEGjs. A few hours later, when I look at the sheer&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Oh... kay... I've been a little optimistic there. ðŸ˜…</p>
<p>I needed to move on, so I decided to switch back to good old Javascript. I used <a href="https://peggyjs.org/">PEGGYjs</a>, which is the properly maintained child of PEGjs. A few hours later, when I look at the sheer size of the grammar, I don't regret my decision. It wasn't exactly trivial to setup in Javascript, so doing it in Go would have been next to impossible for me.</p>
<p>One potential benefit will be the ability to include Javascript lines of code directly in the tables, for example. But that will require an additional syntactic device that is not invented yet. So for now, I'll stick to the original plan. Having Hup Javascript-based shouldn't make it overly slow.</p>
<p>Anyway every code sample shown in the previous posts is now correctly parsed by the parser, and turned into a JSON object.</p>
<pre><code>[</code><br><code>Â  Â  older than 50</code><br><code>Â  Â  = [detailed family]</code><br><code>Â  Â  Â  Â  % #genre( #name age(#age) ) &amp;( #age &gt; 50 )</code><br><code>Â  Â  Â  Â  : #name( #genre #age years old )</code><br><code>Â  Â  | Pedro( man 66 years old )</code><br><code>Â  Â  | Alma( woman 62 years old )</code><br><code>]</code></pre>
<p>This results in the following structure.</p>
<pre id="output" class="">[
  {
    TableName: 'older than 50',
    TableFormula: [
      {
        Operator: 'PRODUCE',
        Shaped: false,
        Operands: [
          {
            T: 'Reference',
            V: 'detailed family'
          }
        ]
      },
      {
        Operator: 'EXTRACT',
        Shaped: false,
        Operands: [
          {
            T: 'Compound',
            V: {
              Functor: {
                T: 'Variable',
                V: '#genre'
              },
              Arguments: [
                {
                  Operator: 'PRODUCE',
                  Shaped: false,
                  Operands: [
                    {
                      T: 'Variable',
                      V: '#name'
                    },
                    {
                      T: 'Compound',
                      V: {
                        Functor: {
                          T: 'Atom',
                          V: 'age'
                        },
                        Arguments: [
                          {
                            Operator: 'PRODUCE',
                            Shaped: false,
                            Operands: [
                              {
                                T: 'Variable',
                                V: '#age'
                              }
                            ]
                          }
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      {
        Operator: 'COPY',
        Shaped: false,
        Operands: [
          {
            T: 'Formula',
            V: [
              {
                Operator: 'PRODUCE',
                Shaped: false,
                Operands: [
                  {
                    T: 'Variable',
                    V: '#age'
                  }
                ]
              },
              {
                Operator: 'GT',
                Shaped: false,
                Operands: [
                  {
                    T: 'Number',
                    V: 50
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        Operator: 'PRODUCE',
        Shaped: false,
        Operands: [
          {
            T: 'Compound',
            V: {
              Functor: {
                T: 'Variable',
                V: '#name'
              },
              Arguments: [
                {
                  Operator: 'PRODUCE',
                  Shaped: false,
                  Operands: [
                    {
                      T: 'Variable',
                      V: '#genre'
                    },
                    {
                      T: 'Variable',
                      V: '#age'
                    },
                    {
                      T: 'Atom',
                      V: 'years'
                    },
                    {
                      T: 'Atom',
                      V: 'old'
                    }
                  ]
                }
              ]
            }
          }
        ]
      }
    ],
    TableValues: [
      [
        {
          T: 'Compound',
          V: {
            Functor: {
              T: 'Atom',
              V: 'Pedro'
            },
            Arguments: [
              {
                Operator: 'PRODUCE',
                Shaped: false,
                Operands: [
                  {
                    T: 'Atom',
                    V: 'man'
                  },
                  {
                    T: 'Number',
                    V: 66
                  },
                  {
                    T: 'Atom',
                    V: 'years'
                  },
                  {
                    T: 'Atom',
                    V: 'old'
                  }
                ]
              }
            ]
          }
        }
      ],
      [
        {
          T: 'Compound',
          V: {
            Functor: {
              T: 'Atom',
              V: 'Alma'
            },
            Arguments: [
              {
                Operator: 'PRODUCE',
                Shaped: false,
                Operands: [
                  {
                    T: 'Atom',
                    V: 'woman'
                  },
                  {
                    T: 'Number',
                    V: 62
                  },
                  {
                    T: 'Atom',
                    V: 'years'
                  },
                  {
                    T: 'Atom',
                    V: 'old'
                  }
                ]
              }
            ]
          }
        }
      ]
    ]
  }
]</pre>
<p>Notice how the first part of a formula gets turned into a <code>Produce</code> operation.</p>
<p>The platform is still Wails, but the target is now Javascript - probably in a Web Worker to keep the UI perfectly reactive. With everything in place, I'm now ready to start the part that I love: implementing the interpreter itself!</p>
<hr>
<p>I'm adding a new Merge operator <code>"</code>, the purpose of which is to join tables on a per value basis.</p>
<pre><code>[ c | 1 | 2 | 3 | 3 | 4 ]</code><br><code>[ d | 5 | bar | moo mew ]</code><br><br><code>[</code><br><code>  Â  merging c and d</code><br><code>Â  Â  = c " d</code><br><code>Â  Â  | 1 5</code><br><code>Â  Â  | 2 bar</code><br><code>Â  Â  | 3 moo mew</code><br><code>Â  Â  | 3</code><br><code>Â  Â  | 4</code><br><code>]</code></pre>
<p>Now I believe the list of operators should be complete.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Parsing in Go, showing in Wails</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/parsing-in-go-showing-in-wails.html"/>
        <id>https://botbreeder.github.io/parsing-in-go-showing-in-wails.html</id>

        <updated>2024-03-25T15:01:37+01:00</updated>
            <summary>
                <![CDATA[
                    It's an achievement. I was stuck for several days, daunted by the prospect of connecting Pigeon, which is a PEG parser generator for Go, to Wails which is my target platform. Well I succeeded! This would be probably nothing to anyone used to working with&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>It's an achievement. I was stuck for several days, daunted by the prospect of connecting <a href="https://github.com/mna/pigeon" target="_blank" rel="noopener noreferrer">Pigeon</a>, which is a PEG parser generator for Go, to <a href="https://wails.io/" target="_blank" rel="noopener noreferrer">Wails</a> which is my target platform.</p>
<p>Well I succeeded!</p>
<figure class="post__image"><img loading="lazy"  src="https://botbreeder.github.io/media/posts/11/parser-first-step.PNG" alt="Screen capture of a successful parsing" width="496" height="492" sizes="(max-width: 48em) 100vw, 768px" srcset="https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-xs.PNG 300w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-sm.PNG 480w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-md.PNG 768w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-lg.PNG 1024w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-xl.PNG 1360w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-2xl.PNG 1600w"></figure>
<p>This would be probably nothing to anyone used to working with Go, but I'm completely new to this. Of course I used an example grammar from the Pigeon repo, a simple math expression one, but the next step is to create &amp; flesh out a real parser for Hup. Just being able to generate the parser and to access it, is already a huge step forward for me!</p>
<p>Yeah, 3 Ã— 5 = 15... it's show time ðŸ¤©</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Hup, design considerations</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup-design-considerations.html"/>
        <id>https://botbreeder.github.io/hup-design-considerations.html</id>

        <updated>2024-03-19T14:34:18+01:00</updated>
            <summary>
                <![CDATA[
                    Right now, nothing has been said about: Multiple tables having the same name can be seen as a problem (which would lead to a namespace-based solution) or as a feature. I prefer to make it a feature. A table name represents a stack of values,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Right now, nothing has been said about:</p>
<ul style="list-style-type: square;">
<li>What to do when multiple tables have the same name,</li>
<li>Error handling,</li>
<li>User-defined functions or operators,</li>
<li>Implementation details.</li>
</ul>
<hr>
<p>Multiple tables having the same name can be seen as a problem (which would lead to a namespace-based solution) or as a feature. I prefer to make it a feature<span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">. A table name represents a stack of values, potentially calculated by several formulas (if several tables have the same name). When a formula is recalculated, the old values are deleted from the stack and the new values are pushed onto it. So the user can always expect a table name to represent values in chronological order of update.</span></p>
<p>Since tables can generate and host other tables, table names can be qualified by path, using a filesystem metaphor. For example, <code>parent/table</code> would mean the table named <code>table</code> that's inside the table named <code>parent</code>.</p>
<hr>
<p>I don't want to make error handling a cause of flow disruption. Instead, the system should be able to continue to work as best as it can, while isolating errors to prevent propagation, and having them be part of the current situation by logging them in dedicated error tables.</p>
<p>As a rule of thumb, when the evaluation of a formula produces an error, the result of that formula is merely an empty list. The built-in <code>ERR</code> table receives a formatted entry about the error. Errors can then be manually handled by the user.</p>
<hr>
<p>User-defined functions are defined in tables. The name of the table is the signature of the function, and the unique value of the table is the body of the function.</p>
<p>User-defined functions always begin with a period "<code>.</code>" character, and are followed by parentheses which receive the arguments, each preceded by a "<code>#</code>" character. The function name's first character is a lowercase letter.</p>
<pre>[ .sqr() | # * # ]<br><br>[<br>Â  Â  squared units<br>Â  Â  = [units] .sqr()<br>Â  Â  | 1<br>Â  Â  | 4<br>Â  Â  | 9<br>]<br><br>[ .pow(#power) | (#) &amp; #power \* ]<br><br>[<br>  Â  units to the third<br>Â  Â  = [units] .pow(3)<br>Â  Â  | 1<br>Â  Â  | 8<br>Â  Â  | 27<br>]</pre>
<p>Remember that evaluation goes from left to right, everything being left-associative. In the body of a user-defined function, a single "<code>#</code>" character represents the values-so-far, or the "previous" operand. If the function was an infix operator, we could say that "<code>#</code>" represents its left-hand side operand.</p>
<p>You might be wondering why the "<code>#</code>" in the <code>pow()</code> function's body is between parentheses. That's because we want want to obtain <code>(1 2 3) * (1 2 3) * (1 2 3)</code> rather than <code>1 * 1 * 1 * 2 * 2 * 2 * 3 * 3 * 3</code>.</p>
<hr>
<p>I'm not yet sure of how all of this will be implemented. But the target language is Go (with Wails for the frontend), and goroutines are probably going to be used extensively.</p>
<p>Oh snap, I know how it will be implemented. By typing on a keyboard with my hands which are fortunately full of fingers.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Hup, other than numbers</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup-working-with-terms.html"/>
        <id>https://botbreeder.github.io/hup-working-with-terms.html</id>

        <updated>2024-03-15T13:00:46+01:00</updated>
            <summary>
                <![CDATA[
                    Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog.</p>
<pre><code>[</code><br><code>  Â  family</code><br><code>  Â  | man( Pedro )</code><br><code>  Â  | woman( Alma )</code><br><code>  Â  | woman( Pepa )</code><br><code>  Â  | woman( Julieta )</code><br><code>  Â  | man( Bruno )</code><br><code>]</code></pre>
<p>There's an Extract operator "<code>%</code>". It does two things: it filters items, and unifies them with a pattern. The pattern contains wildcards, which are tags marked with "<code>#</code>". These tags capture values during the pattern matching process.</p>
<pre><code>[</code><br><code>Â  Â  men only</code><br><code>  Â  = [family] % man( #name )</code><br><code>  Â  | man( Pedro )</code><br><code>  Â  | man( Bruno )</code><br><code>]</code></pre>
<p>The Produce operator "<code>:</code>"Â  will generate new terms using the values captured in tags.</p>
<pre><code>[</code><br><code>  Â  women only</code><br><code>  Â  = [family] % woman( #name ) : human( #name )</code><br><code>  Â  | human( Alma )</code><br><code>  Â  | human( Pepa )</code><br><code>  Â  | human( Julieta )</code><br><code>]</code></pre>
<p>Multiple tags can capture values at once. The generated output can be anything, and has no <em>inherent</em> meaning.</p>
<pre><code>[</code><br><code>Â  Â  detailed family</code><br><code>  Â  | man( Pedro age(66) )</code><br><code>  Â  | woman( Alma age(62) )</code><br><code>  Â  | woman( Pepa age(38) )</code><br><code>  Â  | woman( Julieta age(40) )</code><br><code>  Â  | man( Bruno age(36) )</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  men's age</code><br><code>  Â  = [detailed family] % man( #name age(#age) ) : #name( #age )</code><br><code>  Â  | Pedro( 66 )</code><br><code>  Â  | Bruno( 36 )</code><br><code>]</code></pre>
<p>You can filter with the "<code>&amp;</code>" Copy operator.</p>
<pre><code>[<br>Â  Â  older than 50<br>Â  Â  = [detailed family]<br>  Â  Â  Â  % #genre( #name age(#age) ) &amp;( #age &gt; 50 )<br>  Â  Â  Â  : #name( #genre #age years old )<br>  Â  | Pedro( man 66 years old )<br>  Â  | Alma( woman 62 years old )<br>]<br></code></pre>
<p>Notice how the atoms <code>years</code> and <code>old</code> have been added just for the sake of clarity.</p>
<hr>
<p>In a pattern, an underscore "<code>_</code>" means zero or more elements we don't care about. Additionally, a compound term with nothing between parentheses is the same as an atom.</p>
<pre><code>% being _ human</code></pre>
<p>This pattern would accept all of the following expressions.</p>
<pre><code>being human<br>being a very old human<br>being human()</code></pre>
<p>You can chain pattern matching. In the example below, the <code>#animal</code> wildcard must match in every pattern.</p>
<pre><code>[</code><br><code>Â  Â  pet</code><br><code>Â  Â  | cat</code><br><code>Â  Â  | dog</code><br><code>Â  Â  | mouse</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  pet owners</code><br><code>Â  Â  | Jill has cat</code><br><code>Â  Â  | Jake has fish</code><br><code>Â  Â  | John has mouse</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  owners liking pets</code><br><code>  Â  = [pet owners] % #name has #animal : [pet] % #animal : #name likes #animal</code><br><code>Â  Â  | Jill likes cat</code><br><code>Â  Â  | John likes mouse</code><br><code>]</code></pre>
<p>Note these expressions and pattern matchers are not meant to parse natural language.</p>
<p>Since patterns are stacks, they can be stored in tables.</p>
<pre><code>[</code><br><code>  Â  pet pattern</code><br><code>Â  Â  | #name</code><br><code>Â  Â  | has</code><br><code>Â  Â  | #animal</code><br><code>]</code><br><br><code>[</code><br><code>  Â  owned pets</code><br><code>  Â  = [pet owners] % [pet pattern] : #animal</code><br><code>Â  Â  | cat</code><br><code>Â  Â  | fish</code><br><code>Â  Â  | mouse</code><br><code>]</code></pre>
<p>Naturally, all of these tables (the <code>pet</code>, the <code>pet owners</code>, and <code>pet pattern</code> tables) can be constant or have their values calculated by a formula.</p>
<p>To make a formula produce operators or wildcards, you can quote them with a preceding backtick "<code>`</code>" character.</p>
<pre><code>[</code><br><code>Â  Â  some formula</code><br><code>Â  Â  = `#number `+ 2</code><br><code>Â  Â  | #number</code><br><code>Â  Â  | +</code><br><code>Â  Â  | 2</code><br><code>]</code></pre>
<hr>
<p>Now. Tables can generate tables.</p>
<pre><code>[</code><br><code>Â  Â  family's younger-than tables</code><br><code>Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  % Â  #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  : Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  {#name}'s younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  &amp;( {#age} &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Pedro's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 66 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Alma's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 62 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Pepa's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 38 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Julieta</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Julieta's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 40 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Bruno's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 36 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pepa</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Julieta</code><br><code>Â  Â  Â  Â  ]</code><br><code>]</code></pre>
<p>The formula for this table generates other tables. You first need to focus on the <code>{#name}</code> and <code>{#age}</code> elements. These are insertions, meaning they are not intended to appear "as is" in the generated tables, but rather to be replaced with the actual name and age of the current family member. This is why each generated table has a different title, based on the family member's name, as well as a different filter.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Hup, a few operators</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup-operators.html"/>
        <id>https://botbreeder.github.io/hup-operators.html</id>

        <updated>2024-03-14T10:04:13+01:00</updated>
            <summary>
                <![CDATA[
                    Arithmetic operators are as you'd expect them: add with "+", subtract with "-", multiply with "*", divide with "/". If a stack is preceded by the Shaped operator "$", its length will be modified to fit the length of the "previous" operand. If it's too&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Arithmetic operators are as you'd expect them: add with "<code>+</code>", subtract with "<code>-</code>", multiply with "<code>*</code>", divide with "<code>/</code>".</p>
<p>If a stack is preceded by the Shaped operator "<code>$</code>", its length will be modified to fit the length of the "previous" operand. If it's too long, it gets truncated. If it's too short, it wraps around. Shaping is automatic on stacks of length 1.</p>
<pre><code>[ tens | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 ]<br><br>[ units | 1 | 2 | 3 ]<br><br>[<br>    units wrapping around<br>  Â  = [tens] + $[units]<br>Â  Â  | 11<br>Â  Â  | 22<br>Â  Â  | 33<br>Â  Â  | 41<br>Â  Â  | 52<br>Â  Â  | 63<br>Â  Â  | 71<br>Â  Â  | 82<br>]<br></code></pre>
<p>Boolean operators are: Greater than "<code>&gt;</code>", Less than "<code>&lt;</code>", Greater than or equal "<code>&gt;=</code>", Less than or equal "<code>&lt;=</code>", Equal "<code>==</code>", Different "<code>!=</code>".</p>
<p>There's also And "<code>&amp;&amp;</code>", Or "<code>||</code>", Not "<code>!</code>".</p>
<p>They return <code>1</code> if true, and <code>0</code> if false.</p>
<pre><code>[<br>    units greater than one</code><br><code>Â  Â  = [units] &gt; 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 1</code><br><code>]</code></pre>
<hr>
<p>There is a Copy operator "<code>&amp;</code>". It will repeat the items of a stack a certain number of times, possibly zero times.</p>
<pre><code>[<br>    units twice<br>    = [units] &amp; 2<br>    | 1 | 1 | 2 | 2 | 3 | 3<br>]<br><br>[<br>    handpicked tens<br>  Â  = [tens] &amp; 0 0 2 0 1 0 0 0<br>Â  Â  | 30<br>Â  Â  | 30<br>Â  Â  | 50<br>]</code></pre>
<p>When copying zero times, it acts as a filter. It can be used in conjunction with Boolean operators.</p>
<pre><code>[<br>    keep tens greater than thirty</code><br><code>  Â  = [tens] &amp;( [tens] &gt; 30 )</code><br><code>Â  Â  | 40</code><br><code>Â  Â  | 50</code><br><code>Â  Â  | 60</code><br><code>Â  Â  | 70</code><br><code>Â  Â  | 80</code><br><code>]</code></pre>
<p>To check whether certain items can be found in a stack and count them, the Count operator "<code>â‚¬</code>" can be used.</p>
<pre><code>[<br>    counting</code><br><code>Â  Â  = [tens] â‚¬ 10 10 20 30 50 80</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>]</code></pre>
<p>Together they can make selections.</p>
<pre><code>[ a | 1 | 2 | 3 | 3 ]</code><br><code>[ b | 2 | 3 | 4 | 4 ]</code><br><br><code>[<br>    in 'a' only what you find in 'b'</code><br><code>  Â  = [a] &amp;( [a] â‚¬ [b] )</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3<br>    | 3</code><br><code>]</code><br><br><code>[<br>    in 'b' only what you find in 'a'</code><br><code>  Â  = [b] &amp;( [b] â‚¬ [a] )</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3<br>    | 3</code><br><code>]</code></pre>
<p>In case you're wondering, concatenations are merely juxtapositions.</p>
<pre><code>[</code><br><code>  Â  concatenation of 'a' and 'b'</code><br><code>Â  Â  = [a] [b]<br>    | 1 | 2 | 3 | 3 | 2 | 3 | 4 | 4</code><br><code></code><code>]</code></pre>
<p>There are Union "<code>Â°</code>" and Intersection "<code>^</code>" operators. As you can see, they get rid of duplicates in the process.</p>
<pre><code>[</code><br><code>Â  Â  union of 'a' and 'b'</code><br><code>Â  Â  = [a] Â° [b]</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>Â  Â  | 4</code><br><code>]</code><br><br><code>[</code><br><code>  Â  intersection of 'a' and 'b'</code><br><code>Â  Â  = [a] ^ [b]</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>]</code></pre>
<hr>
<p>The From operator "<code>?</code>" references items in a stack.</p>
<pre><code>[<br>    indices 2 and 3 from tens</code><br><code>  Â  = 2 3 ? [tens]</code><br><code>Â  Â  | 30</code><br><code>Â  Â  | 40</code><br><code>]</code></pre>
<p>The other way around, the Find operator "<code>@</code>" finds (the first occurrence of) items in a stack.</p>
<pre><code>[<br>    in tens find thirty and forty</code><br><code>  Â  = [tens] @ 30 40</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>]</code></pre>
<p>Then you can do combinations.</p>
<pre><code>[ A | 100 | 200 | 300 | 400 ]</code><br><code>[ B | 500 | 600 | 700 | 800 ]</code><br><br><code>[<br>    what's to B what 200 and 300 are to A </code><br><code>    = [A] @ 200 300 ? [B]</code><br><code>Â  Â  | 600</code><br><code>Â  Â  | 700</code><br><code>]</code></pre>
<p>There's no need for a "ternary if" operator. In fact <code>?</code> can act as a switch, because Boolean operators return <code>0</code> or <code>1</code>.</p>
<pre><code>[<br>    a thousand when true</code><br><code>  Â  = [tens] &gt; 30 ? 500 1000</code><br><code>  Â  | 500</code><br><code>  Â  | 500</code><br><code></code><code>  Â  | 500<br> Â  Â | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>]</code></pre>
<hr>
<p>The Reduce "<code>\</code>" operator can be used to transform a stack into a single value by applying another operator repeatedly to each of its values.</p>
<pre><code>[</code><br><code>Â  Â  sum of units</code><br><code>Â  Â  = [units] \+</code><br><code>Â  Â  | 6</code><br><code>]</code></pre>
<hr>
<p>Finally, a formula can begin with an update delay, expressed in milliseconds, followed either by a comma "<code>,</code>" (delay after first change) or a semi-colon "<code>;</code>" (delay after last change). These two are not really operators, rather interpreter directives.</p>
<pre><code>[<br>    jumpy</code><br><code>  Â  = 50, [units] * 2</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 4</code><br><code>Â  Â  | 6</code><br><code>]</code><br><br><code>[<br>    patient</code><br><code>  Â  = 2000; [units] * 2</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 4</code><br><code>Â  Â  | 6</code><br><code>]</code></pre>
<p>The <code>jumpy</code> table will plan an update 50ms after a change, unless an update is already planned. The <code>patient</code> table will plan an update 2 seconds after a change, cancelling any previously planned update.</p>
<p>When time has come to apply an update, if updating wouldn't change the values of a table, the update is cancelled. So for instance, the <code>jumpy</code> table will only get updated if <code>units</code> becomes different AND if it's still different 50ms later. If, in the meantime, <code>units</code> gets back to its initial values, <code>jumpy</code> won't update.</p>
<p>The default is, immediate update.</p>
            ]]>
        </content>
    </entry>
</feed>
