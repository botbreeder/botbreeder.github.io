<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>botbreeder.github.io</title>
    <link href="https://botbreeder.github.io/feed.xml" rel="self" />
    <link href="https://botbreeder.github.io" />
    <updated>2024-03-18T23:41:46+01:00</updated>
    <author>
        <name>Julien Laguerre</name>
    </author>
    <id>https://botbreeder.github.io</id>

    <entry>
        <title>Hup, other than numbers</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup-working-with-terms.html"/>
        <id>https://botbreeder.github.io/hup-working-with-terms.html</id>

        <updated>2024-03-15T13:00:46+01:00</updated>
            <summary>
                <![CDATA[
                    Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog.</p>
<pre><code>[</code><br><code>    family</code><br><code>    | man( Pedro )</code><br><code>    | woman( Alma )</code><br><code>    | woman( Pepa )</code><br><code>    | woman( Julieta )</code><br><code>    | man( Bruno )</code><br><code>]</code></pre>
<p>There's an Extract operator "<code>%</code>". It does two things: it filters items, and unifies them with a pattern. The pattern contains tags marked with "<code>#</code>". These tags capture values during the pattern matching process.</p>
<pre><code>[</code><br><code>    men only</code><br><code>    = [family] % man( #name )</code><br><code>    | man( Pedro )</code><br><code>    | man( Bruno )</code><br><code>]</code></pre>
<p>The Produce operator "<code>:</code>"  will generate new terms using the values captured in tags.</p>
<pre><code>[</code><br><code>    women as humans</code><br><code>    = [family] % woman( #name ) : human( #name )</code><br><code>    | human( Alma )</code><br><code>    | human( Pepa )</code><br><code>    | human( Julieta )</code><br><code>]</code></pre>
<p>Multiple tags can capture values at once. The generated output can be anything, and has no <em>inherent</em> meaning.</p>
<pre><code>[</code><br><code>    detailed family</code><br><code>    | man( Pedro age( 66 ) )</code><br><code>    | woman( Alma age( 62 ) )</code><br><code>    | woman( Pepa age( 38 ) )</code><br><code>    | woman( Julieta age( 40 ) )</code><br><code>    | man( Bruno age( 36 ) )</code><br><code>]</code><br><br><code>[</code><br><code>    men's age</code><br><code>    = [detailed family] % man( #name age( #age ) ) : #name( #age )</code><br><code>    | Pedro( 66 )</code><br><code>    | Bruno( 36 )</code><br><code>]</code></pre>
<p>You can filter with the "<code>&amp;</code>" Copy operator.</p>
<pre><code>[<br>    older than 50<br>    = [detailed family]<br>        % #genre( #name age( #age ) ) &amp;( #age &gt; 50 )<br>        : #name( #genre #age years old )<br>    | Pedro( man 66 years old )<br>    | Alma( woman 62 years old )<br>]<br></code></pre>
<p>Notice how the atoms <code>years</code> and <code>old</code> have been added just for the sake of clarity.</p>
<p>Now. Tables can generate tables.</p>
<pre><code>[</code><br><code>    family's younger-than tables</code><br><code>    =   [detailed family]</code><br><code>        %   #genre( #name age( #age ) )</code><br><code>        :   [</code><br><code>                {#name}'s younger-than table</code><br><code>                =   [detailed family]</code><br><code>                    % #genre( #name age( #age ) )</code><br><code>                    &amp;( {#age} &lt; #age )</code><br><code>                    : #name</code><br><code>            ]</code><br><code>    |   [</code><br><code>            Pedro's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age( #age ) )</code><br><code>                &amp;( 66 &lt; #age )</code><br><code>                : #name</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Alma's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age( #age ) )</code><br><code>                &amp;( 62 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Pepa's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age( #age ) )</code><br><code>                &amp;( 38 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>            |   Julieta</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Julieta's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age( #age ) )</code><br><code>                &amp;( 40 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Bruno's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age( #age ) )</code><br><code>                &amp;( 36 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>            |   Pepa</code><br><code>            |   Julieta</code><br><code>        ]</code><br><code>]</code></pre>
<p>The formula for this table generates other tables. You first need to focus on the <code>{#name}</code> and <code>{#age}</code> elements. These are insertions, meaning they are not intended to appear "as is" in the generated tables, but rather to be replaced with the actual name and age of the current family member. This is why each generated table has a different title, based on the family member's name, as well as a different filter.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Hup, a few operators</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup-operators.html"/>
        <id>https://botbreeder.github.io/hup-operators.html</id>

        <updated>2024-03-14T10:04:13+01:00</updated>
            <summary>
                <![CDATA[
                    Arithmetic operators are as you'd expect them: add with "+", subtract with "-", multiply with "*", divide with "/". If a stack is preceded by the Shaped operator "$", its length will be modified to fit the length of other operands. If it's too long,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Arithmetic operators are as you'd expect them: add with "<code>+</code>", subtract with "<code>-</code>", multiply with "<code>*</code>", divide with "<code>/</code>".</p>
<p>If a stack is preceded by the Shaped operator "<code>$</code>", its length will be modified to fit the length of other operands. If it's too long, it gets truncated. If it's too short, it wraps around. Shaping is automatic on stacks of length 1.</p>
<pre><code>[ tens | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 ]<br><br>[ units | 1 | 2 | 3 ]<br><br>[<br>    units wrapping around<br>    = [tens] + $[units]<br>    | 11<br>    | 22<br>    | 33<br>    | 41<br>    | 52<br>    | 63<br>    | 71<br>    | 82<br>]<br><br>[<br>    tens truncated<br>    = $[tens] + [units]<br>    | 11<br>    | 22<br>    | 33<br>]</code></pre>
<p>Boolean operators are: Greater than "<code>&gt;</code>", Less than "<code>&lt;</code>", Greater than or equal "<code>&gt;=</code>", Less than or equal "<code>&lt;=</code>", Equal "<code>==</code>", Different "<code>!=</code>".</p>
<p>There's also And "<code>&amp;&amp;</code>", Or "<code>||</code>", Not "<code>!</code>".</p>
<p>They return <code>1</code> if true, and <code>0</code> if false.</p>
<pre><code>[<br>    units greater than one</code><br><code>    = [units] &gt; 1</code><br><code>    | 0</code><br><code>    | 1</code><br><code>    | 1</code><br><code>]</code></pre>
<p>There is a Copy operator "<code>&amp;</code>". It will repeat the items of a stack a certain number of times, possibly zero times.</p>
<pre><code>[<br>    units twice<br>    = [units] &amp; 2<br>    | 1 | 1 | 2 | 2 | 3 | 3<br>]<br><br>[<br>    handpicked tens<br>    = [tens] &amp; 0 0 2 0 1 0 0 0<br>    | 30<br>    | 30<br>    | 50<br>]</code></pre>
<p>When copying zero times, it acts as a filter. It can be used in conjunction with Boolean operators.</p>
<pre><code>[<br>    keep tens greater than thirty</code><br><code>    = [tens] &amp;( [tens] &gt; 30 )</code><br><code>    | 40</code><br><code>    | 50</code><br><code>    | 60</code><br><code>    | 70</code><br><code>    | 80</code><br><code>]</code></pre>
<p>To check whether certain items can be found in a stack and count them, the Count operator "<code>€</code>" can be used.</p>
<pre><code>[<br>    counting</code><br><code>    = [tens] € 10 10 20 30 50 80</code><br><code>    | 2</code><br><code>    | 1</code><br><code>    | 1</code><br><code>    | 0</code><br><code>    | 1</code><br><code>    | 0</code><br><code>    | 0</code><br><code>    | 1</code><br><code>]</code></pre>
<p>Together they can make intersections. Kind of.</p>
<pre><code>[ a | 1 | 2 | 3 | 3 ]</code><br><code>[ b | 2 | 3 | 4 | 4 ]</code><br><br><code>[<br>    in 'a' only what you find in 'b'</code><br><code>    = [a] &amp;( [a] € [b] )</code><br><code>    | 2</code><br><code>    | 3<br>    | 3</code><br><code>]</code><br><br><code>[<br>    in 'b' only what you find in 'a'</code><br><code>    = [b] &amp;( [b] € [a] )</code><br><code>    | 2</code><br><code>    | 3<br>    | 3</code><br><code>]</code></pre>
<p>In case you're wondering, concatenations are merely juxtapositions.</p>
<pre><code>[</code><br><code>    concatenation of 'a' and 'b'</code><br><code>    = [a] [b]<br>    | 1 | 2 | 3 | 3 | 2 | 3 | 4 | 4</code><br><code></code><code>]</code></pre>
<p>There are real Union "<code>°</code>" and Intersection "<code>^</code>" operators. As you can see, they get rid of duplicates in the process.</p>
<pre><code>[</code><br><code>    union of 'a' and 'b'</code><br><code>    = [a] ° [b]</code><br><code>    | 1</code><br><code>    | 2</code><br><code>    | 3</code><br><code>    | 4</code><br><code>]</code><br><br><code>[</code><br><code>    intersection of 'a' and 'b'</code><br><code>    = [a] ^ [b]</code><br><code>    | 2</code><br><code>    | 3</code><br><code>]</code></pre>
<p>The Of operator "<code>@</code>" references items in a stack.</p>
<pre><code>[<br>    indices 2 and 3 of tens</code><br><code>    = 2 3 @ [tens]</code><br><code>    | 30</code><br><code>    | 40</code><br><code>]</code></pre>
<p>The other way around, the Index operator "<code>?</code>" finds (the first occurrence of) items in a stack.</p>
<pre><code>[<br>    in tens the indices of thirty and forty</code><br><code>    = [tens] ? 30 40</code><br><code>    | 2</code><br><code>    | 3</code><br><code>]</code></pre>
<p>Then you can do combinations.</p>
<pre><code>[ A | 100 | 200 | 300 | 400 ]</code><br><code>[ B | 500 | 600 | 700 | 800 ]</code><br><br><code>[<br>    what's to B what 200 and 300 are to A </code><br><code>    = [A] ? 200 300 @ [B]</code><br><code>    | 600</code><br><code>    | 700</code><br><code>]</code></pre>
<p>There's no need for a "ternary if" operator. In fact <code>@</code> can act as a switch, because Boolean operators return <code>0</code> or <code>1</code>.</p>
<pre><code>[<br>    a thousand when true</code><br><code>    = [tens] &gt; 30 @ 500 1000</code><br><code>    | 500</code><br><code>    | 500</code><br><code></code><code>    | 500<br>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>]</code></pre>
<p>Finally, a formula can begin with an update delay, expressed in milliseconds, followed either by a comma "<code>,</code>" (delay after first change) or a semi-colon "<code>;</code>" (delay after last change). These two are not really operators, rather interpreter directives.</p>
<pre><code>[<br>    jumpy</code><br><code>    = 50, [units] * 2</code><br><code>    | 2</code><br><code>    | 4</code><br><code>    | 6</code><br><code>]</code><br><br><code>[<br>    patient</code><br><code>    = 2000; [units] * 2</code><br><code>    | 2</code><br><code>    | 4</code><br><code>    | 6</code><br><code>]</code></pre>
<p>The jumpy table will plan an update 50ms after a change, unless an update is already planned. The patient table will plan an update 2 seconds after a change, cancelling any previously planned update.</p>
<p>The default is, immediate update.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Hup, a scripting language</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/hup.html"/>
        <id>https://botbreeder.github.io/hup.html</id>

        <updated>2024-03-11T00:51:07+01:00</updated>
            <summary>
                <![CDATA[
                    This is a stack. 1 2 3 And this is how you add 1 to each item of this stack. 1 2 3 + 1 The result of this expression is another stack. 2 3 4 There is no operator precedence. Instead, everything is left&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>This is a stack.</p>
<pre><code>1 2 3</code></pre>
<p>And this is how you add 1 to each item of this stack.</p>
<pre><code>1 2 3 + 1</code></pre>
<p>The result of this expression is another stack.</p>
<pre><code>2 3 4</code></pre>
<p>There is no operator precedence. Instead, everything is left associative.</p>
<pre><code>1 2 3 + 1 * 2</code></pre>
<p>This expression means <code>(1 2 3 + 1) * 2</code>, which results in:</p>
<pre><code>4 6 8</code></pre>
<p>Now this is a term. Its predicate is the atom "<code>a</code>", and it has 2 arguments: the atom "<code>b</code>" and the atom "<code>c</code>".</p>
<pre><code>a(b c)</code></pre>
<p>When an expression is given in a compound term, the expression is first resolved, before the term receives the resulting stack items as arguments.</p>
<pre><code>P(1 2 3 + 1 * 2)</code></pre>
<p>This is equivalent to:</p>
<pre><code>P(4 6 8)</code></pre>
<p>We'll get back to terms in another post.</p>
<p>Now, this is a table.</p>
<pre><code>[ ]</code></pre>
<p>A table may have a name, a formula, and values obtained by evaluating the formula. The formula is preceded by equal "<code>=</code>" and each value is preceded by a vertical bar "<code>|</code>".</p>
<pre><code>[ example = 1 2 3 + 1 * 2 | 4 | 6 | 8 ]</code></pre>
<p>Whitespace characters are insignificant.</p>
<pre><code>[<br>    example<br>    = 1 2 3 + 1 * 2<br>    | 4<br>    | 6<br>    | 8<br>]</code></pre>
<p>The formula is optional. A table without formula is a constant table.</p>
<pre><code>[<br>    some numbers<br>    | 1<br>    | 2<br>    | 3<br>]</code></pre>
<p>A table's formula can reference values from other tables. The names of referenced tables are enclosed in square brackets.</p>
<pre><code>[</code><br><code>    example</code><br><code>    = [some numbers] + 1 * 2</code><br><code>    | 4</code><br><code>    | 6</code><br><code>    | 8</code><br><code>]</code></pre>
<p>When the values of a referenced table change, the values of the referencing tables are recalculated to reflect the changes. If <code>[some numbers]</code> becomes <code>10 20 30</code>, then <code>[example]</code> will automatically be updated.</p>
<pre><code>[ some numbers | 10 | 20 | 30 ]</code><br><code>[</code><br><code>    example = [some numbers] + 1 * 2</code><br><code>    | 22</code><br><code>    | 42</code><br><code>    | 62</code><br><code>]</code></pre>
<p>The difference between that and a spreadsheet, is that you can make recursive loops.</p>
<pre><code>[ growth = [growth] * 2 | 1 ]</code><br><code>[ growth = [growth] * 2 | 2 ]</code><br><code>[ growth = [growth] * 2 | 4 ]</code><br><code>[ growth = [growth] * 2 | 8 ]</code><br><code>[ growth = [growth] * 2 | 16 ]</code><br><code>[ growth = [growth] * 2 | 32 ]</code><br><code>[ growth = [growth] * 2 | 64 ]</code><br><code>[ growth = [growth] * 2 | 128 ]</code><br><code>[ growth = [growth] * 2 | 256 ]</code></pre>
<p>Here the <code>[growth]</code> table references itself, calculating its new values based on its previous ones. Thus the network of tables is an event driven medium, through which mutations propagate.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Cmdline &amp; toolbar</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/cmdline-and-toolbar.html"/>
        <id>https://botbreeder.github.io/cmdline-and-toolbar.html</id>

        <updated>2024-02-19T09:55:05+01:00</updated>
            <summary>
                <![CDATA[
                    I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously. I've added a small command line at the&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously.</p>
<p>I've added a small command line at the bottom of the screen for power users (e.g., me). Everything should be doable from UI elements alone, and from the command line alone. It should also be possible to create custom commands. Hitting the spacebar gives you instant focus on the command line, and you're ready to type in.</p>
<p>Finally, there's now a toolbar at the top of the screen. It's meant to provide quick access to different toolboxes in the left-hand side panel. I thought it would be handy to always have it on screen.</p>
<p>For both the command line and the toolbar, I used the excellent CSS library <a href="http://augmented-ui.com/" target="_blank" rel="noopener noreferrer">augmented-ui</a> to get those nice diagonal shapes. All in all, the entire thing doesn't look as futuristic as I was planning, but it's still easy on the eye so, I'm satisfied.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Interface</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/interface.html"/>
        <id>https://botbreeder.github.io/interface.html</id>

        <updated>2024-02-15T16:51:04+01:00</updated>
            <summary>
                <![CDATA[
                    Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of whatever I'm about to do. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of whatever I'm about to do. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want it to.</p>
<p>When I work with complex software, I always struggle with the UI to find what I need, because the controls are scattered all around the central area, and often hidden behind menus or dropdowns. Here, I decided to put every control in a panel on the left-hand side of the screen, because I find it easier to merely scroll until I get what I'm looking for.</p>
<p>Then the main area is occupied by workspaces, ready to receive code editors, graphs or 3D visualizers, editable markdown viewers, etc. There again, the user just have to scroll in order to reach them.</p>
<p>My idea is that of a Jupyter style notebook, but in the shape of an outliner. An outliner is basically a recursively folding container, and I don't have that implemented yet. It might be my next move.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Here we go</title>
        <author>
            <name>Julien Laguerre</name>
        </author>
        <link href="https://botbreeder.github.io/here-we-go.html"/>
        <id>https://botbreeder.github.io/here-we-go.html</id>

        <updated>2024-02-11T17:04:07+01:00</updated>
            <summary>
                <![CDATA[
                    Everything has to start somewhere.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Everything has to start somewhere.</p>
            ]]>
        </content>
    </entry>
</feed>
