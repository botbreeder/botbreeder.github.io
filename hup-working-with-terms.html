<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Hup, other than numbers - botbreeder.github.io</title><meta name="description" content="Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://botbreeder.github.io/hup-working-with-terms.html"><link rel="alternate" type="application/atom+xml" href="https://botbreeder.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://botbreeder.github.io/feed.json"><meta property="og:title" content="Hup, other than numbers"><meta property="og:site_name" content="botbreeder.github.io"><meta property="og:description" content="Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;"><meta property="og:url" content="https://botbreeder.github.io/hup-working-with-terms.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://botbreeder.github.io/assets/css/style.css?v=a57748bae4efc673cbad870f97f9d398"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://botbreeder.github.io/hup-working-with-terms.html"},"headline":"Hup, other than numbers","datePublished":"2024-03-15T13:00","dateModified":"2024-03-25T16:22","description":"Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;","author":{"@type":"Person","name":"Julien Laguerre","url":"https://botbreeder.github.io/authors/julien-laguerre/"},"publisher":{"@type":"Organization","name":"Julien Laguerre"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://botbreeder.github.io/">botbreeder.github.io</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://botbreeder.github.io/" title="Frontpage" target="_self">Home</a></li><li><a href="https://github.com/botbreeder" title="Github repo" target="_blank">Github</a></li><li><a href="http://robotvivant.free.fr/" title="Forum Robotvivant" target="_blank">Forum</a></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://botbreeder.github.io/media/website/grid3.jpg" srcset="https://botbreeder.github.io/media/website/responsive/grid3-xs.jpg 300w, https://botbreeder.github.io/media/website/responsive/grid3-sm.jpg 480w, https://botbreeder.github.io/media/website/responsive/grid3-md.jpg 768w, https://botbreeder.github.io/media/website/responsive/grid3-lg.jpg 1024w, https://botbreeder.github.io/media/website/responsive/grid3-xl.jpg 1360w, https://botbreeder.github.io/media/website/responsive/grid3-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" alt="blue matrix"></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-03-15T13:00">03/15/2024</time></div><h1>Hup, other than numbers</h1><div class="post__meta post__meta--author"><a href="https://botbreeder.github.io/authors/julien-laguerre/" class="feed__author invert">Julien Laguerre</a></div></div></header></div><div class="wrapper post__entry"><p>Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog.</p><pre><code>[</code><br><code>    family</code><br><code>    | man( Pedro )</code><br><code>    | woman( Alma )</code><br><code>    | woman( Pepa )</code><br><code>    | woman( Julieta )</code><br><code>    | man( Bruno )</code><br><code>]</code></pre><p>There's an Extract operator "<code>%</code>". It does two things: it filters items, and unifies them with a pattern. The pattern contains wildcards, which are tags marked with "<code>#</code>". These tags capture values during the pattern matching process.</p><pre><code>[</code><br><code>    men only</code><br><code>    = [family] % man( #name )</code><br><code>    | man( Pedro )</code><br><code>    | man( Bruno )</code><br><code>]</code></pre><p>The Produce operator "<code>:</code>"  will generate new terms using the values captured in tags.</p><pre><code>[</code><br><code>    women only</code><br><code>    = [family] % woman( #name ) : human( #name )</code><br><code>    | human( Alma )</code><br><code>    | human( Pepa )</code><br><code>    | human( Julieta )</code><br><code>]</code></pre><p>Multiple tags can capture values at once. The generated output can be anything, and has no <em>inherent</em> meaning.</p><pre><code>[</code><br><code>    detailed family</code><br><code>    | man( Pedro age(66) )</code><br><code>    | woman( Alma age(62) )</code><br><code>    | woman( Pepa age(38) )</code><br><code>    | woman( Julieta age(40) )</code><br><code>    | man( Bruno age(36) )</code><br><code>]</code><br><br><code>[</code><br><code>    men's age</code><br><code>    = [detailed family] % man( #name age(#age) ) : #name( #age )</code><br><code>    | Pedro( 66 )</code><br><code>    | Bruno( 36 )</code><br><code>]</code></pre><p>You can filter with the "<code>&amp;</code>" Copy operator.</p><pre><code>[<br>    older than 50<br>    = [detailed family]<br>        % #genre( #name age(#age) ) &amp;( #age &gt; 50 )<br>        : #name( #genre #age years old )<br>    | Pedro( man 66 years old )<br>    | Alma( woman 62 years old )<br>]<br></code></pre><p>Notice how the atoms <code>years</code> and <code>old</code> have been added just for the sake of clarity.</p><hr><p>In a pattern, an underscore "<code>_</code>" means zero or more elements we don't care about. Additionally, a compound term with nothing between parentheses is the same as an atom.</p><pre><code>% being _ human</code></pre><p>This pattern would accept all of the following expressions.</p><pre><code>being human<br>being a very old human<br>being human()</code></pre><p>You can chain pattern matching. In the example below, the <code>#animal</code> wildcard must match in every pattern.</p><pre><code>[</code><br><code>    pet</code><br><code>    | cat</code><br><code>    | dog</code><br><code>    | mouse</code><br><code>]</code><br><br><code>[</code><br><code>    pet owners</code><br><code>    | Jill has cat</code><br><code>    | Jake has fish</code><br><code>    | John has mouse</code><br><code>]</code><br><br><code>[</code><br><code>    owners liking pets</code><br><code>    = [pet owners] % #name has #animal : [pet] % #animal : #name likes #animal</code><br><code>    | Jill likes cat</code><br><code>    | John likes mouse</code><br><code>]</code></pre><p>Note these expressions and pattern matchers are not meant to parse natural language.</p><p>Since patterns are stacks, they can be stored in tables.</p><pre><code>[</code><br><code>    pet pattern</code><br><code>    | #name</code><br><code>    | has</code><br><code>    | #animal</code><br><code>]</code><br><br><code>[</code><br><code>    owned pets</code><br><code>    = [pet owners] % [pet pattern] : #animal</code><br><code>    | cat</code><br><code>    | fish</code><br><code>    | mouse</code><br><code>]</code></pre><p>Naturally, all of these tables (the <code>pet</code>, the <code>pet owners</code>, and <code>pet pattern</code> tables) can be constant or have their values calculated by a formula.</p><p>To make a formula produce operators or wildcards, you can quote them with a preceding backtick "<code>`</code>" character.</p><pre><code>[</code><br><code>    some formula</code><br><code>    = `#number `+ 2</code><br><code>    | #number</code><br><code>    | +</code><br><code>    | 2</code><br><code>]</code></pre><hr><p>Now. Tables can generate tables.</p><pre><code>[</code><br><code>    family's younger-than tables</code><br><code>    =   [detailed family]</code><br><code>        %   #genre( #name age(#age) )</code><br><code>        :   [</code><br><code>                {#name}'s younger-than table</code><br><code>                =   [detailed family]</code><br><code>                    % #genre( #name age(#age) )</code><br><code>                    &amp;( {#age} &lt; #age )</code><br><code>                    : #name</code><br><code>            ]</code><br><code>    |   [</code><br><code>            Pedro's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age(#age) )</code><br><code>                &amp;( 66 &lt; #age )</code><br><code>                : #name</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Alma's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age(#age) )</code><br><code>                &amp;( 62 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Pepa's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age(#age) )</code><br><code>                &amp;( 38 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>            |   Julieta</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Julieta's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age(#age) )</code><br><code>                &amp;( 40 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>        ]</code><br><code>    |   [</code><br><code>            Bruno's younger-than table</code><br><code>            =   [detailed family]</code><br><code>                % #genre( #name age(#age) )</code><br><code>                &amp;( 36 &lt; #age )</code><br><code>                : #name</code><br><code>            |   Pedro</code><br><code>            |   Alma</code><br><code>            |   Pepa</code><br><code>            |   Julieta</code><br><code>        ]</code><br><code>]</code></pre><p>The formula for this table generates other tables. You first need to focus on the <code>{#name}</code> and <code>{#age}</code> elements. These are insertions, meaning they are not intended to appear "as is" in the generated tables, but rather to be replaced with the actual name and age of the current family member. This is why each generated table has a different title, based on the family member's name, as well as a different filter.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 03/25/2024</p><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://botbreeder.github.io/authors/julien-laguerre/" class="invert" rel="author">Julien Laguerre</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://botbreeder.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://botbreeder.github.io/hup-operators.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Hup, a few operators</a></div><div class="post__nav-next"><a href="https://botbreeder.github.io/hup-design-considerations.html" class="invert post__nav-link" rel="next"><span>Next</span> Hup, design considerations </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://botbreeder.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2024-03-19T14:34" class="feed__date">03/19/2024</time></div><h3 class="h1"><a href="https://botbreeder.github.io/hup-design-considerations.html" class="invert">Hup, design considerations</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2024-03-14T10:04" class="feed__date">03/14/2024</time></div><h3 class="h1"><a href="https://botbreeder.github.io/hup-operators.html" class="invert">Hup, a few operators</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2024-03-11T00:51" class="feed__date">03/11/2024</time></div><h3 class="h1"><a href="https://botbreeder.github.io/hup.html" class="invert">Hup, a scripting language</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://botbreeder.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://botbreeder.github.io/assets/js/scripts.min.js?v=48e9576b9741cf2a93ab25c5689c9f5d"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>