{
    "version": "https://jsonfeed.org/version/1",
    "title": "botbreeder.github.io",
    "description": "",
    "home_page_url": "https://botbreeder.github.io",
    "feed_url": "https://botbreeder.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Julien Laguerre"
    },
    "items": [
        {
            "id": "https://botbreeder.github.io/hup-operators.html",
            "url": "https://botbreeder.github.io/hup-operators.html",
            "title": "Hup, a few operators",
            "summary": "Arithmetic operators are as you'd expect them: add with \"+\", subtract with \"-\", multiply with \"*\", divide with \"/\". If a stack is preceded by the Shaped operator \"$\", its length will be modified to fit the length of other operands. If it's too long,&hellip;",
            "content_html": "<p>Arithmetic operators are as you'd expect them: add with \"<code>+</code>\", subtract with \"<code>-</code>\", multiply with \"<code>*</code>\", divide with \"<code>/</code>\".</p>\n<p>If a stack is preceded by the Shaped operator \"<code>$</code>\", its length will be modified to fit the length of other operands. If it's too long, it gets truncated. If it's too short, it wraps around.</p>\n<pre><code>[ tens<br>    | 10<br>    | 20<br>    | 30<br>    | 40<br>    | 50<br>    | 60<br>    | 70<br>    | 80<br>]<br><br>[ units<br>    | 1<br>    | 2<br>    | 3<br>]<br><br>[ units wrapping around<br>    = [tens] + $[units]<br>    | 11<br>    | 22<br>    | 33<br>    | 41<br>    | 52<br>    | 63<br>    | 71<br>    | 82<br>]</code></pre>\n<p>Boolean operators are: Greater than \"<code>&gt;</code>\", Less than \"<code>&lt;</code>\", Greater than or equal \"<code>&gt;=</code>\", Less than or equal \"<code>&lt;=</code>\", Equal \"<code>==</code>\", Different \"<code>&lt;&gt;</code>\".</p>\n<p>There's also And \"<code>&amp;&amp;</code>\", Or \"<code>||</code>\", Not \"<code>!</code>\".</p>\n<p>They return <code>1</code> if true, and <code>0</code> if false.</p>\n<pre><code>[ units greater than one</code><br><code>    = [units] &gt; 1</code><br><code>    | 0</code><br><code>    | 1</code><br><code>    | 1</code><br><code>]</code></pre>\n<p>There is a Copy operator \"<code>&amp;</code>\". It will repeat the items of a stack a certain number of times, possibly zero times.</p>\n<pre><code>[ handpicked tens<br>    = [tens] &amp; 0 0 2 0 1 0 0 0<br>    | 30<br>    | 30<br>    | 50<br>]</code></pre>\n<p>When copying zero times, it acts as a filter. It can be used in conjuction with boolean operators.</p>\n<pre><code>[ keep tens greater than thirty</code><br><code>    = [tens] &amp; [tens] &gt; 30</code><br><code>    | 40</code><br><code>    | 50</code><br><code>    | 60</code><br><code>    | 70</code><br><code>    | 80</code><br><code>]</code></pre>\n<p>To check whether certain items can be found in a stack and count them, the Count operator \"<code>€</code>\" can be used.</p>\n<pre><code>[ counting</code><br><code>    = [tens] € 10 10 20 30 50 80</code><br><code>    | 2</code><br><code>    | 1</code><br><code>    | 1</code><br><code>    | 0</code><br><code>    | 1</code><br><code>    | 0</code><br><code>    | 0</code><br><code>    | 1</code><br><code>]</code></pre>\n<p>The Fetch operator \"<code>@</code>\" references items in a stack.</p>\n<pre><code>[ third and fourth from tens</code><br><code>    = [tens] @ 2 3</code><br><code>    | 30</code><br><code>    | 40</code><br><code>]</code></pre>\n<p>The other way around, the Index operator \"<code>\\</code>\" finds items in a stack.</p>\n<pre><br><code>[ in tens the indices of thirty and forty</code><br><code>    = 30 40 \\ [tens]</code><br><code>    | 2</code><br><code>    | 3</code><br><code>]</code></pre>\n<p>There's no need for a ternary if operator: <code>@</code> can act as a switch, because boolean operators return <code>1</code> or <code>0</code>.</p>\n<pre><code>[ greater than thirty</code><br><code>    = 500 1000 @ [tens] &gt; 30</code><br><code>    | 500</code><br><code>    | 500</code><br><code></code><code>    | 500<br>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>    | 1000</code><br><code>]</code></pre>\n<p>wip</p>\n<p> </p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-14T10:04:13+01:00",
            "date_modified": "2024-03-14T20:10:58+01:00"
        },
        {
            "id": "https://botbreeder.github.io/hup.html",
            "url": "https://botbreeder.github.io/hup.html",
            "title": "Hup, a scripting language",
            "summary": "This is a stack. 1 2 3 And this is how you add 2 to each item of this stack. 1 2 3 + 2 The result of this expression is another stack. 3 4 5 There is no operator precedence. Instead, an expression reads&hellip;",
            "content_html": "<p>This is a stack.</p>\n<pre><code>1 2 3</code></pre>\n<p>And this is how you add 2 to each item of this stack.</p>\n<pre><code>1 2 3 + 2</code></pre>\n<p>The result of this expression is another stack.</p>\n<pre><code>3 4 5</code></pre>\n<p>There is no operator precedence. Instead, an expression reads from left to right.</p>\n<pre><code>1 2 3 + 2 * 3</code></pre>\n<p>This expression means <code>1 2 3</code> added to whatever follows, namely <code>2 * 3</code>, which results in:</p>\n<pre><code>7 8 9</code></pre>\n<p>Now this is a term. Its functor is the atom \"<code>a</code>\", and it has 2 arguments: the atom \"<code>b</code>\" and the atom \"<code>c</code>\".</p>\n<pre><code>a(b c)</code></pre>\n<p>When an expression is given in a term, the expression is first resolved, before the term receives the resulting stack items as arguments.</p>\n<pre><code>f(1 2 3 + 2 * 3)</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>f(7 8 9)</code></pre>\n<p>Now, this is a table.</p>\n<pre><code>[ ]</code></pre>\n<p>A table may have a name, a formula, and values obtained by evaluating the formula. The formula is preceded by equal \"<code>=</code>\" and each value is preceded by a vertival bar \"<code>|</code>\".</p>\n<pre><code>[ example = 1 2 3 + 2 * 3 | 7 | 8 | 9 ]</code></pre>\n<p>White space is irrelevant.</p>\n<pre><code>[<br>    example<br>    = 1 2 3 + 2 * 3<br>    | 7<br>    | 8<br>    | 9<br>]</code></pre>\n<p>The formula is optional. A table without formula is a constant table.</p>\n<pre><code>[<br>    some numbers<br>    | 1<br>    | 2<br>    | 3<br>]</code></pre>\n<p>The formula of a table can reference the values of other tables. The name of the referenced tables are put between square brackets.</p>\n<pre><code>[</code><br><code>    example</code><br><code>    = [some numbers] + 2 * 3</code><br><code>    | 7</code><br><code>    | 8</code><br><code>    | 9</code><br><code>]</code></pre>\n<p>When the values of a referenced table change, the values of the referencing tables are recalculated to reflect the changes. If <code>[some numbers]</code> changes to <code>10 20 30</code>, then <code>[example]</code> will automatically change too.</p>\n<pre><code>[ some numbers | 10 | 20 | 30 ]</code><br><code>[</code><br><code>    example = [some numbers] + 2 * 3</code><br><code>    | 16</code><br><code>    | 26</code><br><code>    | 36</code><br><code>]</code></pre>\n<p>Thus it is an event driven system.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-11T00:51:07+01:00",
            "date_modified": "2024-03-14T14:28:36+01:00"
        },
        {
            "id": "https://botbreeder.github.io/cmdline-and-toolbar.html",
            "url": "https://botbreeder.github.io/cmdline-and-toolbar.html",
            "title": "Cmdline &amp; toolbar",
            "summary": "I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously. I've added a small command line at the&hellip;",
            "content_html": "<p>I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously.</p>\n<p>I've added a small command line at the bottom of the screen for power users (e.g., me). Everything should be doable from UI elements alone, and from the command line alone. It should also be possible to create custom commands. Hitting the spacebar gives you instant focus on the command line, and you're ready to type in.</p>\n<p>Finally, there's now a toolbar at the top of the screen. It's meant to provide quick access to different toolboxes in the left-hand side panel. I thought it would be handy to always have it on screen.</p>\n<p>For both the command line and the toolbar, I used the excellent css library <a href=\"http://augmented-ui.com/\" target=\"_blank\" rel=\"noopener noreferrer\">augmented-ui</a> to get those nice diagonal shapes. All in all, the entire thing doesn't look as futuristic as I was planning, but it's still easy on the eye so, I'm satisfied.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-19T09:55:05+01:00",
            "date_modified": "2024-02-19T10:00:44+01:00"
        },
        {
            "id": "https://botbreeder.github.io/interface.html",
            "url": "https://botbreeder.github.io/interface.html",
            "title": "Interface",
            "summary": "Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of Semantify3D. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want it to. When I&hellip;",
            "content_html": "<p>Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of Semantify3D. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want it to.</p>\n<p>When I work with complex softwares, I always struggle with the UI to find what I need, because the controls are scattered all around the central area, and often hidden behind menus or dropdowns. Here, I decided to put every control in a panel on the left-hand side of the screen, because I find it easier to merely scroll until I get what I'm looking for.</p>\n<p>Then the main area is occupied by workspaces, ready to receive code editors, graphs or 3D visualizers, editable markdown viewers, ...etc. There again, the user just have to scroll in order to reach them.</p>\n<p>My idea is that of a Jupyter style notebook, but in the shape of an outliner. An outliner is basically a recursively folding container, and I don't have that implemented yet. It might be my next move.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-15T16:51:04+01:00",
            "date_modified": "2024-02-15T16:58:18+01:00"
        },
        {
            "id": "https://botbreeder.github.io/here-we-go.html",
            "url": "https://botbreeder.github.io/here-we-go.html",
            "title": "Here we go",
            "summary": "Everything has to start somewhere.",
            "content_html": "<p>Everything has to start somewhere.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-11T17:04:07+01:00",
            "date_modified": "2024-02-11T17:04:07+01:00"
        }
    ]
}
