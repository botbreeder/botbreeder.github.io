{
    "version": "https://jsonfeed.org/version/1",
    "title": "botbreeder.github.io",
    "description": "",
    "home_page_url": "https://botbreeder.github.io",
    "feed_url": "https://botbreeder.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Julien Laguerre"
    },
    "items": [
        {
            "id": "https://botbreeder.github.io/parsing-in-javascript-after-all.html",
            "url": "https://botbreeder.github.io/parsing-in-javascript-after-all.html",
            "title": "Parsing in Javascript after all",
            "summary": "Oh, kay, I've been a bit optimistic there. ðŸ˜… I needed to move on, so I decided to switch back to good old Javascript. I'm using PEGGYjs, which is the properly maintained descendant of PEGjs. A few hours later, when I look at the sheer&hellip;",
            "content_html": "<p>Oh, kay, I've been a bit optimistic there. ðŸ˜…</p>\n<p>I needed to move on, so I decided to switch back to good old Javascript. I'm using <a href=\"https://peggyjs.org/\">PEGGYjs</a>, which is the properly maintained descendant of PEGjs. A few hours later, when I look at the sheer size of the grammar, I don't regret my decision. It wasn't exactly trivial to setup in Javascript, so doing it in Go would have been next to impossible for me.</p>\n<p>One potential benefit would be the ability to include Javascript lines of code directly in the tables, for example. But for now, I'll stick to the original plan.</p>\n<p>Every code sample shown in the previous posts is correctly parsed by the parser, and turned into a JSON object.</p>\n<pre><code>[</code><br><code>Â  Â  older than 50</code><br><code>Â  Â  = [detailed family]</code><br><code>Â  Â  Â  Â  % #genre( #name age(#age) ) &amp;( #age &gt; 50 )</code><br><code>Â  Â  Â  Â  : #name( #genre #age years old )</code><br><code>Â  Â  | Pedro( man 66 years old )</code><br><code>Â  Â  | Alma( woman 62 years old )</code><br><code>]</code></pre>\n<p>This results in the following structure.</p>\n<pre id=\"output\" class=\"\">[\n  {\n    TableName: 'older than 50',\n    TableFormula: [\n      {\n        Operator: 'PRODUCE',\n        Operands: [\n          {\n            T: 'Reference',\n            V: 'detailed family'\n          }\n        ]\n      },\n      {\n        Operator: 'EXTRACT',\n        Shaped: false,\n        Operands: [\n          {\n            T: 'Compound',\n            V: {\n              Functor: {\n                T: 'Variable',\n                V: '#genre'\n              },\n              Arguments: [\n                {\n                  Operator: 'PRODUCE',\n                  Operands: [\n                    {\n                      T: 'Variable',\n                      V: '#name'\n                    },\n                    {\n                      T: 'Compound',\n                      V: {\n                        Functor: {\n                          T: 'Atom',\n                          V: 'age'\n                        },\n                        Arguments: [\n                          {\n                            Operator: 'PRODUCE',\n                            Operands: [\n                              {\n                                T: 'Variable',\n                                V: '#age'\n                              }\n                            ]\n                          }\n                        ]\n                      }\n                    }\n                  ]\n                }\n              ]\n            }\n          }\n        ]\n      },\n      {\n        Operator: 'COPY',\n        Shaped: false,\n        Operands: [\n          {\n            T: 'Formula',\n            V: [\n              {\n                Operator: 'PRODUCE',\n                Operands: [\n                  {\n                    T: 'Variable',\n                    V: '#age'\n                  }\n                ]\n              },\n              {\n                Operator: 'GT',\n                Shaped: false,\n                Operands: [\n                  {\n                    T: 'Number',\n                    V: 50\n                  }\n                ]\n              }\n            ]\n          }\n        ]\n      },\n      {\n        Operator: 'PRODUCE',\n        Shaped: false,\n        Operands: [\n          {\n            T: 'Compound',\n            V: {\n              Functor: {\n                T: 'Variable',\n                V: '#name'\n              },\n              Arguments: [\n                {\n                  Operator: 'PRODUCE',\n                  Operands: [\n                    {\n                      T: 'Variable',\n                      V: '#genre'\n                    },\n                    {\n                      T: 'Variable',\n                      V: '#age'\n                    },\n                    {\n                      T: 'Atom',\n                      V: 'years'\n                    },\n                    {\n                      T: 'Atom',\n                      V: 'old'\n                    }\n                  ]\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ],\n    TableValues: [\n      [\n        {\n          T: 'Compound',\n          V: {\n            Functor: {\n              T: 'Atom',\n              V: 'Pedro'\n            },\n            Arguments: [\n              {\n                Operator: 'PRODUCE',\n                Operands: [\n                  {\n                    T: 'Atom',\n                    V: 'man'\n                  },\n                  {\n                    T: 'Number',\n                    V: 66\n                  },\n                  {\n                    T: 'Atom',\n                    V: 'years'\n                  },\n                  {\n                    T: 'Atom',\n                    V: 'old'\n                  }\n                ]\n              }\n            ]\n          }\n        }\n      ],\n      [\n        {\n          T: 'Compound',\n          V: {\n            Functor: {\n              T: 'Atom',\n              V: 'Alma'\n            },\n            Arguments: [\n              {\n                Operator: 'PRODUCE',\n                Operands: [\n                  {\n                    T: 'Atom',\n                    V: 'woman'\n                  },\n                  {\n                    T: 'Number',\n                    V: 62\n                  },\n                  {\n                    T: 'Atom',\n                    V: 'years'\n                  },\n                  {\n                    T: 'Atom',\n                    V: 'old'\n                  }\n                ]\n              }\n            ]\n          }\n        }\n      ]\n    ]\n  }\n]</pre>\n<p>Notice how the first part of a formula gets turned into a <code>Produce</code> operation.</p>\n<p>The platform is still Wails, but the target is now Javascript - probably in a Web Worker to keep the UI perfectly reactive. With everything in place, I'm ready to start the part that I love: implementing the interpreter itself!</p>\n<hr>\n<p>I'm adding a new Merge operator <code>\"</code>, the purpose of which is to join tables on a per value basis.</p>\n<pre><code>[ c | 1 | 2 | 3 | 3 | 4 ]</code><br><code>[ d | 5 | bar | moo mew ]</code><br><br><code>[</code><br><code>Â  Â  merging a and b</code><br><code>Â  Â  = c \" d</code><br><code>Â  Â  | 1 5</code><br><code>Â  Â  | 2 bar</code><br><code>Â  Â  | 3 moo mew</code><br><code>Â  Â  | 3</code><br><code>Â  Â  | 4</code><br><code>]</code></pre>\n<p>Now I think I used all the characters available to people using typical QWERTY keyboards.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-04-01T15:55:02+02:00",
            "date_modified": "2024-04-01T20:18:09+02:00"
        },
        {
            "id": "https://botbreeder.github.io/parsing-in-go-showing-in-wails.html",
            "url": "https://botbreeder.github.io/parsing-in-go-showing-in-wails.html",
            "title": "Parsing in Go, showing in Wails",
            "summary": "It's an achievement. I was stuck for several days, daunted by the prospect of connecting Pigeon, which is a PEG parser generator for Go, to Wails which is my target platform. Well I succeeded! This would be probably nothing to anyone used to working with&hellip;",
            "content_html": "<p>It's an achievement. I was stuck for several days, daunted by the prospect of connecting <a href=\"https://github.com/mna/pigeon\" target=\"_blank\" rel=\"noopener noreferrer\">Pigeon</a>, which is a PEG parser generator for Go, to <a href=\"https://wails.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Wails</a> which is my target platform.</p>\n<p>Well I succeeded!</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://botbreeder.github.io/media/posts/11/parser-first-step.PNG\" alt=\"Screen capture of a successful parsing\" width=\"496\" height=\"492\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-xs.PNG 300w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-sm.PNG 480w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-md.PNG 768w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-lg.PNG 1024w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-xl.PNG 1360w ,https://botbreeder.github.io/media/posts/11/responsive/parser-first-step-2xl.PNG 1600w\"></figure>\n<p>This would be probably nothing to anyone used to working with Go, but I'm completely new to this. Of course I used an example grammar from the Pigeon repo, a simple math expression one, but the next step is to create &amp; flesh out a real parser for Hup. Just being able to generate the parser and to access it, is already a huge step forward for me!</p>\n<p>Yeah, 3 Ã— 5 = 15... it's show time ðŸ¤©</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-25T15:01:37+01:00",
            "date_modified": "2024-03-25T15:35:33+01:00"
        },
        {
            "id": "https://botbreeder.github.io/hup-design-considerations.html",
            "url": "https://botbreeder.github.io/hup-design-considerations.html",
            "title": "Hup, design considerations",
            "summary": "Right now, nothing has been said about: Multiple tables having the same name can be seen as a problem (which would lead to a namespace-based solution) or as a feature. I prefer to make it a feature. A table name represents a stack of values,&hellip;",
            "content_html": "<p>Right now, nothing has been said about:</p>\n<ul style=\"list-style-type: square;\">\n<li>What to do when multiple tables have the same name,</li>\n<li>Error handling,</li>\n<li>User-defined functions or operators,</li>\n<li>Implementation details.</li>\n</ul>\n<hr>\n<p>Multiple tables having the same name can be seen as a problem (which would lead to a namespace-based solution) or as a feature. I prefer to make it a feature<span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">. A table name represents a stack of values, potentially calculated by several formulas (if several tables have the same name). When a formula is recalculated, the old values are deleted from the stack and the new values are pushed onto it. So the user can always expect a table name to represent values in chronological order of update.</span></p>\n<p>Since tables can generate and host other tables, table names can be qualified by path, using a filesystem metaphor. For example, <code>parent/table</code> would mean the table named <code>table</code> that's inside the table named <code>parent</code>.</p>\n<hr>\n<p>I don't want to make error handling a cause of flow disruption. Instead, the system should be able to continue to work as best as it can, while isolating errors to prevent propagation, and having them be part of the current situation by logging them in dedicated error tables.</p>\n<p>As a rule of thumb, when the evaluation of a formula produces an error, the result of that formula is merely an empty list. The built-in <code>ERR</code> table receives a formatted entry about the error. Errors can then be manually handled by the user.</p>\n<hr>\n<p>User-defined functions are defined in tables. The name of the table is the signature of the function, and the unique value of the table is the body of the function.</p>\n<p>User-defined functions always begin with a period \"<code>.</code>\" character, and are followed by parentheses which receive the arguments, each preceded by a \"<code>#</code>\" character. The function name's first character is a lowercase letter.</p>\n<pre>[ .sqr() | # * # ]<br><br>[<br>Â  Â  squared units<br>Â  Â  = [units] .sqr()<br>Â  Â  | 1<br>Â  Â  | 4<br>Â  Â  | 9<br>]<br><br>[ .pow(#power) | (#) &amp; #power \\* ]<br><br>[<br>  Â  units to the third<br>Â  Â  = [units] .pow(3)<br>Â  Â  | 1<br>Â  Â  | 8<br>Â  Â  | 27<br>]</pre>\n<p>Remember that evaluation goes from left to right, everything being left-associative. In the body of a user-defined function, a single \"<code>#</code>\" character represents the values-so-far, or the \"previous\" operand. If the function was an infix operator, we could say that \"<code>#</code>\" represents its left-hand side operand.</p>\n<p>You might be wondering why the \"<code>#</code>\" in the <code>pow()</code> function's body is between parentheses. That's because we want want to obtain <code>(1 2 3) * (1 2 3) * (1 2 3)</code> rather than <code>1 * 1 * 1 * 2 * 2 * 2 * 3 * 3 * 3</code>.</p>\n<hr>\n<p>I'm not yet sure of how all of this will be implemented. But the target language is Go (with Wails for the frontend), and goroutines are probably going to be used extensively.</p>\n<p>Oh snap, I know how it will be implemented. By typing on a keyboard with my hands which are fortunately full of fingers.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-19T14:34:18+01:00",
            "date_modified": "2024-03-25T16:18:26+01:00"
        },
        {
            "id": "https://botbreeder.github.io/hup-working-with-terms.html",
            "url": "https://botbreeder.github.io/hup-working-with-terms.html",
            "title": "Hup, other than numbers",
            "summary": "Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog. [ family | man( Pedro&hellip;",
            "content_html": "<p>Hup can not only handle numbers, but also other types of terms: atoms, compound terms, and even embedded tables. Intuitively, a term can designate any element of meaning. Compound terms have the following syntax, which is vaguely reminiscent of Prolog.</p>\n<pre><code>[</code><br><code>  Â  family</code><br><code>  Â  | man( Pedro )</code><br><code>  Â  | woman( Alma )</code><br><code>  Â  | woman( Pepa )</code><br><code>  Â  | woman( Julieta )</code><br><code>  Â  | man( Bruno )</code><br><code>]</code></pre>\n<p>There's an Extract operator \"<code>%</code>\". It does two things: it filters items, and unifies them with a pattern. The pattern contains wildcards, which are tags marked with \"<code>#</code>\". These tags capture values during the pattern matching process.</p>\n<pre><code>[</code><br><code>Â  Â  men only</code><br><code>  Â  = [family] % man( #name )</code><br><code>  Â  | man( Pedro )</code><br><code>  Â  | man( Bruno )</code><br><code>]</code></pre>\n<p>The Produce operator \"<code>:</code>\"Â  will generate new terms using the values captured in tags.</p>\n<pre><code>[</code><br><code>  Â  women only</code><br><code>  Â  = [family] % woman( #name ) : human( #name )</code><br><code>  Â  | human( Alma )</code><br><code>  Â  | human( Pepa )</code><br><code>  Â  | human( Julieta )</code><br><code>]</code></pre>\n<p>Multiple tags can capture values at once. The generated output can be anything, and has no <em>inherent</em> meaning.</p>\n<pre><code>[</code><br><code>Â  Â  detailed family</code><br><code>  Â  | man( Pedro age(66) )</code><br><code>  Â  | woman( Alma age(62) )</code><br><code>  Â  | woman( Pepa age(38) )</code><br><code>  Â  | woman( Julieta age(40) )</code><br><code>  Â  | man( Bruno age(36) )</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  men's age</code><br><code>  Â  = [detailed family] % man( #name age(#age) ) : #name( #age )</code><br><code>  Â  | Pedro( 66 )</code><br><code>  Â  | Bruno( 36 )</code><br><code>]</code></pre>\n<p>You can filter with the \"<code>&amp;</code>\" Copy operator.</p>\n<pre><code>[<br>Â  Â  older than 50<br>Â  Â  = [detailed family]<br>  Â  Â  Â  % #genre( #name age(#age) ) &amp;( #age &gt; 50 )<br>  Â  Â  Â  : #name( #genre #age years old )<br>  Â  | Pedro( man 66 years old )<br>  Â  | Alma( woman 62 years old )<br>]<br></code></pre>\n<p>Notice how the atoms <code>years</code> and <code>old</code> have been added just for the sake of clarity.</p>\n<hr>\n<p>In a pattern, an underscore \"<code>_</code>\" means zero or more elements we don't care about. Additionally, a compound term with nothing between parentheses is the same as an atom.</p>\n<pre><code>% being _ human</code></pre>\n<p>This pattern would accept all of the following expressions.</p>\n<pre><code>being human<br>being a very old human<br>being human()</code></pre>\n<p>You can chain pattern matching. In the example below, the <code>#animal</code> wildcard must match in every pattern.</p>\n<pre><code>[</code><br><code>Â  Â  pet</code><br><code>Â  Â  | cat</code><br><code>Â  Â  | dog</code><br><code>Â  Â  | mouse</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  pet owners</code><br><code>Â  Â  | Jill has cat</code><br><code>Â  Â  | Jake has fish</code><br><code>Â  Â  | John has mouse</code><br><code>]</code><br><br><code>[</code><br><code>Â  Â  owners liking pets</code><br><code>  Â  = [pet owners] % #name has #animal : [pet] % #animal : #name likes #animal</code><br><code>Â  Â  | Jill likes cat</code><br><code>Â  Â  | John likes mouse</code><br><code>]</code></pre>\n<p>Note these expressions and pattern matchers are not meant to parse natural language.</p>\n<p>Since patterns are stacks, they can be stored in tables.</p>\n<pre><code>[</code><br><code>  Â  pet pattern</code><br><code>Â  Â  | #name</code><br><code>Â  Â  | has</code><br><code>Â  Â  | #animal</code><br><code>]</code><br><br><code>[</code><br><code>  Â  owned pets</code><br><code>  Â  = [pet owners] % [pet pattern] : #animal</code><br><code>Â  Â  | cat</code><br><code>Â  Â  | fish</code><br><code>Â  Â  | mouse</code><br><code>]</code></pre>\n<p>Naturally, all of these tables (the <code>pet</code>, the <code>pet owners</code>, and <code>pet pattern</code> tables) can be constant or have their values calculated by a formula.</p>\n<p>To make a formula produce operators or wildcards, you can quote them with a preceding backtick \"<code>`</code>\" character.</p>\n<pre><code>[</code><br><code>Â  Â  some formula</code><br><code>Â  Â  = `#number `+ 2</code><br><code>Â  Â  | #number</code><br><code>Â  Â  | +</code><br><code>Â  Â  | 2</code><br><code>]</code></pre>\n<hr>\n<p>Now. Tables can generate tables.</p>\n<pre><code>[</code><br><code>Â  Â  family's younger-than tables</code><br><code>Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  % Â  #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  : Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  {#name}'s younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  &amp;( {#age} &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Pedro's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 66 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Alma's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 62 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Pepa's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 38 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Julieta</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Julieta's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 40 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  ]</code><br><code>Â  Â  | Â  [</code><br><code>Â  Â  Â  Â  Â  Â  Bruno's younger-than table</code><br><code>Â  Â  Â  Â  Â  Â  = Â  [detailed family]</code><br><code>  Â  Â  Â  Â  Â  Â  Â  % #genre( #name age(#age) )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  &amp;( 36 &lt; #age )</code><br><code>Â  Â  Â  Â  Â  Â  Â  Â  : #name</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pedro</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Alma</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Pepa</code><br><code>Â  Â  Â  Â  Â  Â  | Â  Julieta</code><br><code>Â  Â  Â  Â  ]</code><br><code>]</code></pre>\n<p>The formula for this table generates other tables. You first need to focus on the <code>{#name}</code> and <code>{#age}</code> elements. These are insertions, meaning they are not intended to appear \"as is\" in the generated tables, but rather to be replaced with the actual name and age of the current family member. This is why each generated table has a different title, based on the family member's name, as well as a different filter.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-15T13:00:46+01:00",
            "date_modified": "2024-03-25T16:22:31+01:00"
        },
        {
            "id": "https://botbreeder.github.io/hup-operators.html",
            "url": "https://botbreeder.github.io/hup-operators.html",
            "title": "Hup, a few operators",
            "summary": "Arithmetic operators are as you'd expect them: add with \"+\", subtract with \"-\", multiply with \"*\", divide with \"/\". If a stack is preceded by the Shaped operator \"$\", its length will be modified to fit the length of the \"previous\" operand. If it's too&hellip;",
            "content_html": "<p>Arithmetic operators are as you'd expect them: add with \"<code>+</code>\", subtract with \"<code>-</code>\", multiply with \"<code>*</code>\", divide with \"<code>/</code>\".</p>\n<p>If a stack is preceded by the Shaped operator \"<code>$</code>\", its length will be modified to fit the length of the \"previous\" operand. If it's too long, it gets truncated. If it's too short, it wraps around. Shaping is automatic on stacks of length 1.</p>\n<pre><code>[ tens | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 ]<br><br>[ units | 1 | 2 | 3 ]<br><br>[<br>    units wrapping around<br>  Â  = [tens] + $[units]<br>Â  Â  | 11<br>Â  Â  | 22<br>Â  Â  | 33<br>Â  Â  | 41<br>Â  Â  | 52<br>Â  Â  | 63<br>Â  Â  | 71<br>Â  Â  | 82<br>]<br></code></pre>\n<p>Boolean operators are: Greater than \"<code>&gt;</code>\", Less than \"<code>&lt;</code>\", Greater than or equal \"<code>&gt;=</code>\", Less than or equal \"<code>&lt;=</code>\", Equal \"<code>==</code>\", Different \"<code>!=</code>\".</p>\n<p>There's also And \"<code>&amp;&amp;</code>\", Or \"<code>||</code>\", Not \"<code>!</code>\".</p>\n<p>They return <code>1</code> if true, and <code>0</code> if false.</p>\n<pre><code>[<br>    units greater than one</code><br><code>Â  Â  = [units] &gt; 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 1</code><br><code>]</code></pre>\n<hr>\n<p>There is a Copy operator \"<code>&amp;</code>\". It will repeat the items of a stack a certain number of times, possibly zero times.</p>\n<pre><code>[<br>    units twice<br>    = [units] &amp; 2<br>    | 1 | 1 | 2 | 2 | 3 | 3<br>]<br><br>[<br>    handpicked tens<br>  Â  = [tens] &amp; 0 0 2 0 1 0 0 0<br>Â  Â  | 30<br>Â  Â  | 30<br>Â  Â  | 50<br>]</code></pre>\n<p>When copying zero times, it acts as a filter. It can be used in conjunction with Boolean operators.</p>\n<pre><code>[<br>    keep tens greater than thirty</code><br><code>  Â  = [tens] &amp;( [tens] &gt; 30 )</code><br><code>Â  Â  | 40</code><br><code>Â  Â  | 50</code><br><code>Â  Â  | 60</code><br><code>Â  Â  | 70</code><br><code>Â  Â  | 80</code><br><code>]</code></pre>\n<p>To check whether certain items can be found in a stack and count them, the Count operator \"<code>â‚¬</code>\" can be used.</p>\n<pre><code>[<br>    counting</code><br><code>Â  Â  = [tens] â‚¬ 10 10 20 30 50 80</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 0</code><br><code>Â  Â  | 1</code><br><code>]</code></pre>\n<p>Together they can make selections.</p>\n<pre><code>[ a | 1 | 2 | 3 | 3 ]</code><br><code>[ b | 2 | 3 | 4 | 4 ]</code><br><br><code>[<br>    in 'a' only what you find in 'b'</code><br><code>  Â  = [a] &amp;( [a] â‚¬ [b] )</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3<br>    | 3</code><br><code>]</code><br><br><code>[<br>    in 'b' only what you find in 'a'</code><br><code>  Â  = [b] &amp;( [b] â‚¬ [a] )</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3<br>    | 3</code><br><code>]</code></pre>\n<p>In case you're wondering, concatenations are merely juxtapositions.</p>\n<pre><code>[</code><br><code>  Â  concatenation of 'a' and 'b'</code><br><code>Â  Â  = [a] [b]<br>    | 1 | 2 | 3 | 3 | 2 | 3 | 4 | 4</code><br><code></code><code>]</code></pre>\n<p>There are Union \"<code>Â°</code>\" and Intersection \"<code>^</code>\" operators. As you can see, they get rid of duplicates in the process.</p>\n<pre><code>[</code><br><code>Â  Â  union of 'a' and 'b'</code><br><code>Â  Â  = [a] Â° [b]</code><br><code>Â  Â  | 1</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>Â  Â  | 4</code><br><code>]</code><br><br><code>[</code><br><code>  Â  intersection of 'a' and 'b'</code><br><code>Â  Â  = [a] ^ [b]</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>]</code></pre>\n<hr>\n<p>The From operator \"<code>?</code>\" references items in a stack.</p>\n<pre><code>[<br>    indices 2 and 3 from tens</code><br><code>  Â  = 2 3 ? [tens]</code><br><code>Â  Â  | 30</code><br><code>Â  Â  | 40</code><br><code>]</code></pre>\n<p>The other way around, the Find operator \"<code>@</code>\" finds (the first occurrence of) items in a stack.</p>\n<pre><code>[<br>    in tens find thirty and forty</code><br><code>  Â  = [tens] @ 30 40</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 3</code><br><code>]</code></pre>\n<p>Then you can do combinations.</p>\n<pre><code>[ A | 100 | 200 | 300 | 400 ]</code><br><code>[ B | 500 | 600 | 700 | 800 ]</code><br><br><code>[<br>    what's to B what 200 and 300 are to A </code><br><code>    = [A] @ 200 300 ? [B]</code><br><code>Â  Â  | 600</code><br><code>Â  Â  | 700</code><br><code>]</code></pre>\n<p>There's no need for a \"ternary if\" operator. In fact <code>?</code> can act as a switch, because Boolean operators return <code>0</code> or <code>1</code>.</p>\n<pre><code>[<br>    a thousand when true</code><br><code>  Â  = [tens] &gt; 30 ? 500 1000</code><br><code>  Â  | 500</code><br><code>  Â  | 500</code><br><code></code><code>  Â  | 500<br> Â  Â | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>  Â  | 1000</code><br><code>]</code></pre>\n<hr>\n<p>The Reduce \"<code>\\</code>\" operator can be used to transform a stack into a single value by applying another operator repeatedly to each of its values.</p>\n<pre><code>[</code><br><code>Â  Â  sum of units</code><br><code>Â  Â  = [units] \\+</code><br><code>Â  Â  | 6</code><br><code>]</code></pre>\n<hr>\n<p>Finally, a formula can begin with an update delay, expressed in milliseconds, followed either by a comma \"<code>,</code>\" (delay after first change) or a semi-colon \"<code>;</code>\" (delay after last change). These two are not really operators, rather interpreter directives.</p>\n<pre><code>[<br>    jumpy</code><br><code>  Â  = 50, [units] * 2</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 4</code><br><code>Â  Â  | 6</code><br><code>]</code><br><br><code>[<br>    patient</code><br><code>  Â  = 2000; [units] * 2</code><br><code>Â  Â  | 2</code><br><code>Â  Â  | 4</code><br><code>Â  Â  | 6</code><br><code>]</code></pre>\n<p>The <code>jumpy</code> table will plan an update 50ms after a change, unless an update is already planned. The <code>patient</code> table will plan an update 2 seconds after a change, cancelling any previously planned update.</p>\n<p>When time has come to apply an update, if updating wouldn't change the values of a table, the update is cancelled. So for instance, the <code>jumpy</code> table will only get updated if <code>units</code> becomes different AND if it's still different 50ms later. If, in the meantime, <code>units</code> gets back to its initial values, <code>jumpy</code> won't update.</p>\n<p>The default is, immediate update.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-14T10:04:13+01:00",
            "date_modified": "2024-03-25T16:05:16+01:00"
        },
        {
            "id": "https://botbreeder.github.io/hup.html",
            "url": "https://botbreeder.github.io/hup.html",
            "title": "Hup, a scripting language",
            "summary": "This is a stack. 1 2 3 And this is how you add 1 to each item of this stack. 1 2 3 + 1 The result of this expression is another stack. 2 3 4 There is no operator precedence. Instead, everything is left&hellip;",
            "content_html": "<p>This is a stack.</p>\n<pre><code>1 2 3</code></pre>\n<p>And this is how you add 1 to each item of this stack.</p>\n<pre><code>1 2 3 + 1</code></pre>\n<p>The result of this expression is another stack.</p>\n<pre><code>2 3 4</code></pre>\n<p>There is no operator precedence. Instead, everything is left associative.</p>\n<pre><code>1 2 3 + 1 * 2</code></pre>\n<p>This expression means <code>(1 2 3 + 1) * 2</code>, which results in:</p>\n<pre><code>4 6 8</code></pre>\n<hr>\n<p>Now this is a term. Its predicate is the atom \"<code>a</code>\", and it has 2 arguments: the atom \"<code>b</code>\" and the atom \"<code>c</code>\".</p>\n<pre><code>a(b c)</code></pre>\n<p>When an expression is given in a compound term, the expression is first resolved, before the term receives the resulting stack items as arguments.</p>\n<pre><code>P(1 2 3 + 1 * 2)</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>P(4 6 8)</code></pre>\n<p>We'll get back to terms in another post.</p>\n<hr>\n<p>Now, this is a table.</p>\n<pre><code>[ ]</code></pre>\n<p>A table may have a name, a formula, and values obtained by evaluating the formula. The formula is preceded by equal \"<code>=</code>\" and each value is preceded by a vertical bar \"<code>|</code>\".</p>\n<pre><code>[ example = 1 2 3 + 1 * 2 | 4 | 6 | 8 ]</code></pre>\n<p>Whitespace characters are insignificant.</p>\n<pre><code>[<br>    example<br>    = 1 2 3 + 1 * 2<br>    | 4<br>    | 6<br>    | 8<br>]</code></pre>\n<p>The formula is optional. A table without formula is a constant table.</p>\n<pre><code>[<br>    some numbers<br>    | 1<br>    | 2<br>    | 3<br>]</code></pre>\n<p>A table's formula can reference values from other tables. The names of referenced tables are enclosed in square brackets.</p>\n<pre><code>[</code><br><code>    example</code><br><code>    = [some numbers] + 1 * 2</code><br><code>    | 4</code><br><code>    | 6</code><br><code>    | 8</code><br><code>]</code></pre>\n<p>When the values of a referenced table change, the values of the referencing tables are recalculated to reflect the changes. If <code>[some numbers]</code> becomes <code>10 20 30</code>, then <code>[example]</code> will automatically be updated.</p>\n<pre><code>[ some numbers | 10 | 20 | 30 ]</code><br><code>[</code><br><code>    example = [some numbers] + 1 * 2</code><br><code>    | 22</code><br><code>    | 42</code><br><code>    | 62</code><br><code>]</code></pre>\n<p>Thus the network of tables is an event driven medium, through which mutations propagate.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-03-11T00:51:07+01:00",
            "date_modified": "2024-03-19T14:57:39+01:00"
        },
        {
            "id": "https://botbreeder.github.io/cmdline-and-toolbar.html",
            "url": "https://botbreeder.github.io/cmdline-and-toolbar.html",
            "title": "Cmdline &amp; toolbar",
            "summary": "I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously. I've added a small command line at the&hellip;",
            "content_html": "<p>I'm ditching the outliner idea, as on second thought it is unclear how the interface would need to be manipulated. Instead, I'll rely on views, which are selections of workspaces that the user wants to see simultaneously.</p>\n<p>I've added a small command line at the bottom of the screen for power users (e.g., me). Everything should be doable from UI elements alone, and from the command line alone. It should also be possible to create custom commands. Hitting the spacebar gives you instant focus on the command line, and you're ready to type in.</p>\n<p>Finally, there's now a toolbar at the top of the screen. It's meant to provide quick access to different toolboxes in the left-hand side panel. I thought it would be handy to always have it on screen.</p>\n<p>For both the command line and the toolbar, I used the excellent CSS library <a href=\"http://augmented-ui.com/\" target=\"_blank\" rel=\"noopener noreferrer\">augmented-ui</a> to get those nice diagonal shapes. All in all, the entire thing doesn't look as futuristic as I was planning, but it's still easy on the eye so, I'm satisfied.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-19T09:55:05+01:00",
            "date_modified": "2024-03-15T00:07:36+01:00"
        },
        {
            "id": "https://botbreeder.github.io/interface.html",
            "url": "https://botbreeder.github.io/interface.html",
            "title": "Interface",
            "summary": "Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of whatever I'm about to do. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want&hellip;",
            "content_html": "<p>Starting from the end, I wanted to try a certain type of UI, very minimalistic, before I jump into the core concepts of whatever I'm about to do. I've been experimenting for 2 weeks, and now have a UI draft that looks how I want it to.</p>\n<p>When I work with complex software, I always struggle with the UI to find what I need, because the controls are scattered all around the central area, and often hidden behind menus or dropdowns. Here, I decided to put every control in a panel on the left-hand side of the screen, because I find it easier to merely scroll until I get what I'm looking for.</p>\n<p>Then the main area is occupied by workspaces, ready to receive code editors, graphs or 3D visualizers, editable markdown viewers, etc. There again, the user just have to scroll in order to reach them.</p>\n<p>My idea is that of a Jupyter style notebook, but in the shape of an outliner. An outliner is basically a recursively folding container, and I don't have that implemented yet. It might be my next move.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-15T16:51:04+01:00",
            "date_modified": "2024-03-15T00:16:30+01:00"
        },
        {
            "id": "https://botbreeder.github.io/here-we-go.html",
            "url": "https://botbreeder.github.io/here-we-go.html",
            "title": "Here we go",
            "summary": "Everything has to start somewhere.",
            "content_html": "<p>Everything has to start somewhere.</p>",
            "author": {
                "name": "Julien Laguerre"
            },
            "tags": [
            ],
            "date_published": "2024-02-11T17:04:07+01:00",
            "date_modified": "2024-03-15T00:08:13+01:00"
        }
    ]
}
